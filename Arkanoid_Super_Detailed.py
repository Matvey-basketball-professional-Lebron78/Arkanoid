# ============================================================================
# АРКАНОИД - ПОЛНАЯ ИГРА С ПОДРОБНЫМИ КОММЕНТАРИЯМИ
# ============================================================================

import pygame
import sys
import os
import math
from pygame.draw import *

# ============================================================================
# ИНИЦИАЛИЗАЦИЯ
# ============================================================================

pygame.init()

# Размеры экрана
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 800

# Размеры игрового поля
WINDOW_WIDTH = 833
WINDOW_HEIGHT = 685
WINDOW_X = 55
WINDOW_Y = 60

# Цвета
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
BLUE = (0, 0, 255)
RED = (255, 0, 0)
GREY = (100, 100, 100)

# Цвета для плиток
COLORS = ['GREY', 'RED', 'BLUE', 'ORANGE', 'PINK', 'GREEN']

# Окно
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Арканоид - Полная версия")
clock = pygame.time.Clock()

# ============================================================================
# КЛАСС ПЛИТКИ (Bricks)
# ============================================================================

class Plitka:
    """Класс плитки/кирпичика которые уничтожаются при попадании шарика"""
    
    # Классовые переменные (общие для всех плиток)
    vse_plitki = []  # Список всех плиток
    
    def __init__(self):
        self.x = 0          # X координата центра
        self.y = 0          # Y координата центра
        self.l = 62         # Длина (ширина)
        self.d = 26         # Глубина (высота)
        self.ryad = 0       # Номер ряда
        self.stolb = 0      # Номер столбца
        self.color = 'GREY' # Цвет
        self.zhizn = True   # Статус жизни (живая ли плитка)


def create_pl():
    """Создает 78 плиток (13 столбцов × 6 рядов) с координатами и цветами"""
    
    # Создаем 78 пустых плиток
    for i in range(78):
        pl = Plitka()
        Plitka.vse_plitki.append(pl)
    
    # Заполняем координаты и цвета
    i = 0
    j = 0
    
    for plit in Plitka.vse_plitki:
        # Номер столбца и ряда
        plit.stolb = i
        plit.ryad = j
        
        # Координаты
        plit.x = 86 + plit.l * i
        plit.y = 73 + plit.d * j
        
        # Цвет зависит от ряда
        plit.color = COLORS[j]
        
        i += 1
        # ========================================================================
        # IF: if i > 12:
        # ========================================================================
        # ОБЪЯСНЕНИЕ:
        # - i - это номер столбца (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
        # - В каждом ряду только 13 плиток (индексы 0-12)
        # - Когда i становится 13, нужно перейти на новый ряд
        # - i > 12 значит что мы разместили уже 13 плиток (0-12)
        # - Тогда обнуляем i (начинаем новый ряд с нуля)
        # - И увеличиваем j (переходим на следующий ряд)
        # 
        # ПРИМЕРЫ:
        # Сначала: i=0,1,2,...,11,12 (первый ряд - 13 плиток)
        # Потом: i=13 → условие верно (13 > 12) → i=0, j=1
        # Потом: i=0,1,2,...,11,12 (второй ряд - 13 плиток)
        # И так далее пока не создадим 6 рядов
        if i > 12:
            i = 0
            j += 1


def place_pl(screen, Plitka_obj):
    """Рисует плитку на экране"""
    x = Plitka_obj.x
    y = Plitka_obj.y
    l = Plitka_obj.l
    d = Plitka_obj.d
    color = Plitka_obj.color
    zhizn = Plitka_obj.zhizn
    
    # ========================================================================
    # IF: if zhizn:
    # ========================================================================
    # ОБЪЯСНЕНИЕ:
    # - zhizn это переменная True/False (живая ли плитка)
    # - if zhizn: значит "если zhizn равно True"
    # - То есть: если плитка еще живая, тогда рисуем её
    # - Если плитка разрушена (zhizn = False), то мы её не рисуем
    # 
    # ЛОГИКА:
    # True → рисуем плитку на экран
    # False → пропускаем, не рисуем
    # 
    # ПОЧЕМУ ТАК?
    # После того как в плитку попал мяч, мы устанавливаем zhizn = False
    # На следующем кадре эта плитка не будет нарисована (вот так она исчезает)
    if zhizn:  # Если плитка еще живая
        rect(screen, color, (x - l/2, y - d/2, l, d))
        rect(screen, WHITE, (x - l/2, y - d/2, l, d), 1)


def destroy(Plitka_obj, Ball_obj):
    """Проверяет столкновение шарика с плиткой"""
    
    # ========================================================================
    # IF: if Plitka_obj.zhizn:
    # ========================================================================
    # ОБЪЯСНЕНИЕ:
    # - Сначала проверяем живая ли плитка
    # - Если плитка уже разрушена (zhizn = False), то нет смысла проверять столкновение
    # - Экономим производительность: не считаем расстояние для мертвых плиток
    # 
    # ЛОГИКА:
    # Живая плитка (True) → проверяем столкновение
    # Мертвая плитка (False) → пропускаем проверку
    if Plitka_obj.zhizn:
        # Ищем ближайшую точку на плитке к центру шарика
        closest_x = max(Plitka_obj.x - Plitka_obj.l/2, 
                        min(Ball_obj.rect.x, Plitka_obj.x + Plitka_obj.l/2))
        closest_y = max(Plitka_obj.y - Plitka_obj.d/2, 
                        min(Ball_obj.rect.y, Plitka_obj.y + Plitka_obj.d/2))
        
        # Расстояние от центра шарика до ближайшей точки
        distance = (closest_x - Ball_obj.rect.x)**2 + (closest_y - Ball_obj.rect.y)**2
        
        # ====================================================================
        # IF: if distance <= (Ball_obj.radius)**2:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - distance это расстояние от центра шарика до ближайшей точки на плитке
        # - Ball_obj.radius это радиус шарика
        # - Если расстояние МЕНЬШЕ ИЛИ РАВНО радиусу шарика в квадрате
        # - То значит шарик КАСАЕТСЯ плитку (произошло столкновение!)
        # 
        # ФОРМУЛА:
        # Расстояние = √((x1-x2)² + (y1-y2)²)
        # Но мы сравниваем с (радиус)² без извлечения корня (для скорости)
        # 
        # ПРИМЕРЫ:
        # Радиус шарика = 10 пикселей
        # Радиус² = 100
        # distance = 50 → столкновение (50 ≤ 100)
        # distance = 100 → столкновение (100 ≤ 100)
        # distance = 150 → нет столкновения (150 > 100)
        if distance <= (Ball_obj.radius)**2:
            Plitka_obj.zhizn = False  # Плитка разрушена
            Ball_obj.angle = -Ball_obj.angle  # Шарик отскакивает
            return True
    
    return False


# ============================================================================
# КЛАСС ПЛАТФОРМЫ
# ============================================================================

class Platform:
    """Класс платформы для отбивания шарика"""
    
    def __init__(self, x, y, width, height, speed, window_width, window_x):
        self.rect = pygame.Rect(x, y, width, height)
        self.speed = speed
        self.screen_width = window_x + window_width
    
    def move_left(self, window_x):
        """Движение влево"""
        # ====================================================================
        # IF: if self.rect.left > window_x:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - self.rect.left это левая граница платформы
        # - window_x это левая граница игрового поля (55 пиксель)
        # - Проверяем: может ли платформа двигаться влево?
        # 
        # ЛОГИКА:
        # Если левая граница платформы БОЛЬШЕ левой границы поля
        # → платформа еще не у края, можно двигать влево
        # 
        # Если левая граница платформы РАВНА или МЕНЬШЕ левой границы поля
        # → платформа уже у края, дальше нельзя
        # 
        # ПРИМЕРЫ:
        # window_x = 55
        # self.rect.left = 100 → 100 > 55 (True) → можно двигать влево
        # self.rect.left = 55 → 55 > 55 (False) → нельзя, у края
        # self.rect.left = 30 → 30 > 55 (False) → нельзя, уже прошли
        if self.rect.left > window_x:
            self.rect.x -= self.speed
    
    def move_right(self):
        """Движение вправо"""
        # ====================================================================
        # IF: if self.rect.right < self.screen_width:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - self.rect.right это правая граница платформы
        # - self.screen_width это правая граница игрового поля
        # - Проверяем: может ли платформа двигаться вправо?
        # 
        # ЛОГИКА:
        # Если правая граница платформы МЕНЬШЕ правой границы поля
        # → платформа еще не у края, можно двигать вправо
        # 
        # Если правая граница платформы БОЛЬШЕ или РАВНА правой границе поля
        # → платформа уже у края, дальше нельзя
        # 
        # ПРИМЕРЫ:
        # screen_width = 888 (55 + 833)
        # self.rect.right = 800 → 800 < 888 (True) → можно двигать вправо
        # self.rect.right = 888 → 888 < 888 (False) → нельзя, у края
        # self.rect.right = 900 → 900 < 888 (False) → нельзя, уже прошли
        if self.rect.right < self.screen_width:
            self.rect.x += self.speed
    
    def draw(self, screen):
        """Рисует платформу"""
        pygame.draw.rect(screen, BLUE, self.rect)


# ============================================================================
# КЛАСС МЯЧА
# ============================================================================

class Ball:
    """Класс мяча"""
    
    def __init__(self, x, y, radius, speed, window_width, window_height, window_x, window_y):
        self.rect = pygame.Rect(x - radius, y - radius, radius * 2, radius * 2)
        self.radius = radius
        self.speed = speed
        self.angle = math.pi / 4
        self.screen_width = window_x + window_width
        self.screen_height = window_y + window_height
        self.active = False
    
    def activate(self, platform_rect):
        """Активирует мяч (выпускает его с платформы)"""
        # ====================================================================
        # IF: if not self.active:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - self.active это флаг (True/False)
        # - True = мяч летает, False = мяч спит на платформе
        # - if not self.active: значит "если мяч НЕ активен"
        # 
        # ЛОГИКА:
        # Мяч спит (False) → условие True → активируем мяч
        # Мяч летает (True) → условие False → не трогаем его
        # 
        # ПОЧЕМУ ПРОВЕРЯЕМ?
        # Чтобы не запускать мяч несколько раз
        # Если уже летит, не нужно его запускать еще раз
        # 
        # ПРИМЕР:
        # Сначала: active = False
        # Нажимаем кнопку → if not False (True) → активируем
        # Теперь: active = True
        # Нажимаем еще → if not True (False) → ничего не делаем
        if not self.active:
            self.active = True
            self.rect.midbottom = platform_rect.midtop
            self.angle = math.pi / 4
    
    def update(self, platform):
        """Обновляет позицию мяча"""
        # ====================================================================
        # IF: if not self.active:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - Проверяем активен ли мяч
        # - Если мяч НЕ активен (спит на платформе), то не обновляем его
        # - return выходит из функции раньше (остальной код не выполняется)
        # 
        # ЛОГИКА:
        # Мяч спит (False) → if not False (True) → выходим, ничего не считаем
        # Мяч летает (True) → if not True (False) → продолжаем считать движение
        # 
        # ЗАЧЕМ ТАК?
        # Если мяч спит, нет смысла считать его движение
        # Экономим вычисления процессора
        if not self.active:
            return
        
        dx = math.cos(self.angle) * self.speed
        dy = -math.sin(self.angle) * self.speed
        
        self.rect.x += dx
        self.rect.y += dy
        
        self._check_boundary_collision()
        self._check_platform_collision(platform)
    
    def _check_boundary_collision(self):
        """Отталкивание от стен"""
        # ====================================================================
        # IF: if self.rect.left <= WINDOW_X:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - Проверяем коснулась ли левая граница шарика левой границы поля
        # - self.rect.left это левая граница шарика
        # - WINDOW_X это левая граница поля (55)
        # - Если они РАВНЫ или шарик ПРОШЕЛ дальше → столкновение с левой стеной!
        # 
        # ЛОГИКА:
        # self.rect.left = 54 → 54 <= 55 (True) → шарик вышел за границу
        # self.rect.left = 55 → 55 <= 55 (True) → шарик коснулся граница
        # self.rect.left = 56 → 56 <= 55 (False) → шарик в норме
        # 
        # ЧТО ДЕЛАТЬ:
        # Положить шарик РОВНО на границу (чтобы не прошел)
        # Развернуть его в другую сторону (angle = π - angle)
        if self.rect.left <= WINDOW_X:
            self.rect.left = WINDOW_X
            self.angle = math.pi - self.angle
        # ====================================================================
        # ELIF: elif self.rect.right >= self.screen_width:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - elif значит "иначе если" (проверяем если первое условие было False)
        # - Проверяем коснулась ли ПРАВАЯ граница шарика ПРАВОЙ границы поля
        # - self.rect.right это правая граница шарика
        # - self.screen_width это правая граница поля
        # - Если они РАВНЫ или шарик ПРОШЕЛ дальше → столкновение с правой стеной!
        # 
        # ЛОГИКА:
        # screen_width = 888
        # self.rect.right = 889 → 889 >= 888 (True) → шарик вышел за границу
        # self.rect.right = 888 → 888 >= 888 (True) → шарик коснулся граница
        # self.rect.right = 887 → 887 >= 888 (False) → шарик в норме
        # 
        # ПОЧЕМУ elif?
        # Шарик не может одновременно касаться левой И правой стены
        # Если уже столкнулся с левой (if выполнено), то правую проверять не нужно
        # elif экономит вычисления
        elif self.rect.right >= self.screen_width:
            self.rect.right = self.screen_width
            self.angle = math.pi - self.angle
        
        # ====================================================================
        # IF: if self.rect.top <= 0:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - Проверяем коснулась ли верхняя граница шарика верхней границы экрана
        # - self.rect.top это верхняя граница шарика
        # - 0 это верхняя граница экрана (0 пиксель)
        # - Если шарик ВЫШЕЛ ВЫШЕ или КОСНУЛСЯ верхней границы
        # 
        # ЛОГИКА:
        # self.rect.top = -1 → -1 <= 0 (True) → шарик прошел выше
        # self.rect.top = 0 → 0 <= 0 (True) → шарик коснулся
        # self.rect.top = 1 → 1 <= 0 (False) → шарик в норме
        # 
        # ЧТО ДЕЛАЕТСЯ:
        # Развернуть шарик вниз (angle = -angle)
        # Это отражение от горизонтальной линии
        # 
        # ПОЧЕМУ НЕ ELIF?
        # Потому что это вертикальная стена, а выше мы проверяли горизонтальные
        # Шарик может одновременно коснуться угла → нужны оба условия
        if self.rect.top <= 0:
            self.rect.top = 0
            self.angle = -self.angle
    
    def _check_platform_collision(self, platform):
        """Отталкивание от платформы"""
        # ====================================================================
        # IF: if self.rect.colliderect(platform.rect) and self.rect.bottom >= platform.rect.top:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # Это ДВОЙНОЕ условие с "and" (И)
        # - self.rect.colliderect(platform.rect) проверяет пересекаются ли два прямоугольника
        #   Возвращает True если да, False если нет
        # - self.rect.bottom >= platform.rect.top проверяет: шарик сверху от платформы?
        #   bottom это нижняя граница шарика
        #   top это верхняя граница платформы
        #   Если bottom >= top значит шарик НАД платформой (падает сверху)
        # 
        # ПОЧЕМУ ДВА УСЛОВИЯ?
        # Нужны оба, потому что:
        # 1. colliderect = пересекаются ли
        # 2. bottom >= top = падает ли сверху
        # 
        # Если только colliderect, то шарик будет отскакивать даже если летит снизу
        # Это странно - платформа должна отбивать только сверху
        # 
        # and ЗНАЧИТ: оба условия должны быть True одновременно
        # 
        # ПРИМЕРЫ:
        # colliderect = True, bottom >= top = True → оба True → True (отбиваем)
        # colliderect = True, bottom >= top = False → один False → False (не отбиваем)
        # colliderect = False, bottom >= top = True → один False → False (не отбиваем)
        if self.rect.colliderect(platform.rect) and self.rect.bottom >= platform.rect.top:
            delta_x = self.rect.centerx - platform.rect.centerx
            new_delta_x = max(-1, min(1, delta_x / (platform.rect.width / 2)))
            
            max_angle = math.radians(75)
            real_angle = new_delta_x * max_angle
            
            self.angle = math.pi / 2 + real_angle
            self.rect.bottom = platform.rect.top
    
    def draw(self, screen):
        """Рисует мяч"""
        pygame.draw.circle(screen, RED, self.rect.center, self.radius)


# ============================================================================
# ФУНКЦИИ ДЛЯ СЧЕТА И ФОНА
# ============================================================================

def load_background(image_path='images/background/-1.png'):
    """Загружает фоновое изображение"""
    # ========================================================================
    # TRY-EXCEPT КОНСТРУКЦИЯ
    # ========================================================================
    # ОБЪЯСНЕНИЕ:
    # try: пытаемся выполнить код (может быть ошибка)
    # except: если произошла ошибка, выполняем этот блок
    # 
    # ЗАЧЕМ?
    # Если файл не существует, программа не упадет с ошибкой
    # Вместо этого создадим черный фон (fallback)
    # 
    # БЕЗ try-except:
    # Ошибка → программа крашится → игра закрывается
    # 
    # С try-except:
    # Ошибка → создаем черный фон → игра продолжает работать
    try:
        # Пытаемся загрузить изображение с диска
        image = pygame.image.load(image_path)
        # Конвертируем для лучшей производительности
        image = image.convert()
        # Масштабируем под размер экрана
        return pygame.transform.scale(image, (SCREEN_WIDTH, SCREEN_HEIGHT))
    # ========================================================================
    # EXCEPT - ЧТО МОЖЕТ ПОЙТИ НЕ ТАК?
    # ========================================================================
    # Возможные ошибки в try блоке:
    # 1. FileNotFoundError - файл не найден
    # 2. pygame.error - неправильный формат файла
    # 3. Другие ошибки при работе с файлом
    # 
    # except: (без указания типа) ловит ВСЕ ошибки одновременно
    except:
        # Если произошла ошибка - создаем черный фон вместо загрузки
        bg = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        bg.fill(BLACK)
        return bg


def load_digit_images(folder="images/digits", width=80, height=80):
    """Загружает изображения цифр (0-9)"""
    images = {}
    
    for i in range(10):
        file_path = os.path.join(folder, f"{i}.png")
        
        # ====================================================================
        # IF: if os.path.exists(file_path):
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - os.path.exists() проверяет существует ли файл
        # - Возвращает True если файл есть, False если нет
        # 
        # ЛОГИКА:
        # Файл существует → True → пытаемся загрузить
        # Файл НЕ существует → False → создаем заглушку
        # 
        # ПРИМЕРЫ:
        # Файл "images/digits/0.png" есть → True
        # Файл "images/digits/999.png" нет → False
        if os.path.exists(file_path):
            # ================================================================
            # ВЛОЖЕННЫЙ TRY-EXCEPT
            # ================================================================
            # Пытаемся загрузить файл (внутри if)
            try:
                # Загружаем изображение цифры
                img = pygame.image.load(file_path)
                # Масштабируем до нужного размера и сохраняем
                images[str(i)] = pygame.transform.scale(img, (width, height))
            # ================================================================
            # EXCEPT - если ошибка при загрузке
            # ================================================================
            # Возможные ошибки:
            # 1. pygame.error - файл поврежден
            # 2. Ошибка формата изображения
            # 3. Другие ошибки при обработке файла
            except:
                # Если не смогли загрузить - создаем текстовую цифру
                images[str(i)] = create_digit_placeholder(i, width, height)
        # ====================================================================
        # ELSE - если файла нет
        # ====================================================================
        # else выполняется если условие if было False (файла не существует)
        else:
            # Создаем временную заглушку с текстом
            images[str(i)] = create_digit_placeholder(i, width, height)
    
    return images


def create_digit_placeholder(digit, width, height):
    """Создает временное изображение цифры"""
    surf = pygame.Surface((width, height))
    surf.fill(GREY)
    
    font = pygame.font.SysFont(None, 60)
    text = font.render(str(digit), True, WHITE)
    text_rect = text.get_rect(center=(width//2, height//2))
    surf.blit(text, text_rect)
    
    return surf


def draw_score(surface, score, images, x, y, spacing=5, digits=6):
    """Рисует счет на экране"""
    # ========================================================================
    # IF: if not images:
    # ========================================================================
    # ОБЪЯСНЕНИЕ:
    # - images это словарь с изображениями цифр
    # - if not images: проверяет пустой ли словарь
    # - not images = True если словарь пустой
    # - not images = False если в словаре что-то есть
    # 
    # ЛОГИКА:
    # Словарь пустой {} → not {} = True → выходим (нечего рисовать)
    # Словарь с данными {0: img, 1: img, ...} → not {...} = False → рисуем
    # 
    # ЗАЧЕМ ПРОВЕРКА?
    # Если словарь пустой, то рисовать нечего
    # Код ниже будет ошибку, поэтому выходим раньше с return
    if not images:
        return
    
    score_str = str(score).zfill(digits)
    
    # ========================================================================
    # IF: if "0" in images:
    # ========================================================================
    # ОБЪЯСНЕНИЕ:
    # - Проверяем есть ли в словаре ключ "0"
    # - "0" in images возвращает True если ключ существует
    # 
    # ЛОГИКА:
    # Ключ "0" есть в словаре → True → берем ширину цифры 0
    # Ключа "0" нет в словаре → False → используем стандартную ширину 80
    # 
    # ПРИМЕР:
    # images = {"0": img1, "1": img2, ...}
    # "0" in images → True
    # 
    # images = {} (пустой)
    # "0" in images → False
    if "0" in images:
        digit_width = images["0"].get_width()
    else:
        # Если нет цифры 0 - используем 80 как стандарт
        digit_width = 80
    
    for i, digit in enumerate(score_str):
        # ====================================================================
        # IF: if digit in images:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - Проверяем есть ли это цифра в словаре
        # - digit это одна цифра строки (например "5")
        # - images это словарь с цифрами
        # 
        # ЛОГИКА:
        # Цифра есть в словаре → True → рисуем её
        # Цифры нет в словаре → False → пропускаем
        # 
        # ПРИМЕР:
        # score_str = "000005"
        # На каждой итерации:
        # digit = "0" → "0" in images = True → рисуем
        # digit = "0" → "0" in images = True → рисуем
        # ...
        # digit = "5" → "5" in images = True → рисуем
        if digit in images:
            img = images[digit]
            x_pos = x + i * (digit_width + spacing)
            surface.blit(img, (x_pos, y))


# ============================================================================
# ИНИЦИАЛИЗАЦИЯ ИГРЫ
# ============================================================================

create_pl()

background = load_background('images/background/-1.png')
digit_images = load_digit_images("images/digits", 80, 80)

platform = Platform(
    x=WINDOW_WIDTH // 2 + WINDOW_X - 50,
    y=WINDOW_HEIGHT + WINDOW_Y - 30,
    width=100,
    height=20,
    speed=5,
    window_width=WINDOW_WIDTH,
    window_x=WINDOW_X
)

ball = Ball(
    x=platform.rect.centerx,
    y=platform.rect.top - 10,
    radius=10,
    speed=10,
    window_width=WINDOW_WIDTH,
    window_height=WINDOW_HEIGHT,
    window_x=WINDOW_X,
    window_y=WINDOW_Y
)

current_score = 0
display_x = 920
display_y = 157
digit_spacing = 0
num_digits = 4

finished = False
FPS = 30

# ============================================================================
# ГЛАВНЫЙ ЦИКЛ ИГРЫ
# ============================================================================

while not finished:
    # ========================================================================
    # IF: if current_score < 78:
    # ========================================================================
    # ОБЪЯСНЕНИЕ:
    # - current_score это количество разрушенных плиток
    # - 78 это общее количество плиток (13 × 6)
    # - Проверяем: все ли плитки разрушены?
    # 
    # ЛОГИКА:
    # score < 78 (не все разрушены) → True → продолжаем игру
    # score >= 78 (все разрушены) → False → конец игры, победа!
    # 
    # ПРИМЕРЫ:
    # score = 0 → 0 < 78 = True → играем
    # score = 50 → 50 < 78 = True → играем
    # score = 77 → 77 < 78 = True → играем (одна плитка осталась)
    # score = 78 → 78 < 78 = False → конец, победили!
    if current_score < 78:
        
        screen.fill(BLACK)
        
        mouse_button = pygame.mouse.get_pressed()
        
        # ====================================================================
        # IF: if mouse_button[0]:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - mouse_button это кортеж из 3 элементов
        # - mouse_button[0] это ЛЕВАЯ кнопка (True/False)
        # - mouse_button[1] это СРЕДНЯЯ кнопка
        # - mouse_button[2] это ПРАВАЯ кнопка
        # - Проверяем нажата ли левая кнопка мыши
        # 
        # ЛОГИКА:
        # Левая кнопка нажата → True → двигаем платформу влево
        # Левая кнопка НЕ нажата → False → ничего не делаем
        # 
        # ПРИМЕРЫ:
        # mouse_button = (True, False, False) → левая нажата
        # mouse_button = (False, True, False) → средняя нажата
        # mouse_button = (False, False, True) → правая нажата
        # mouse_button = (False, False, False) → ничего не нажато
        if mouse_button[0]:  # Левая кнопка - влево
            platform.move_left(window_x=WINDOW_X)
        
        # ====================================================================
        # IF: if mouse_button[2]:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - mouse_button[2] это ПРАВАЯ кнопка мыши
        # - Проверяем нажата ли правая кнопка
        if mouse_button[2]:  # Правая кнопка - вправо
            platform.move_right()
        
        # ====================================================================
        # IF: if mouse_button[1]:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - mouse_button[1] это СРЕДНЯЯ кнопка мыши
        # - Проверяем нажата ли средняя кнопка
        if mouse_button[1]:  # Средняя кнопка - активация мяча
            ball.activate(platform.rect)
        
        # ====================================================================
        # IF: if not ball.active:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - Проверяем спит ли мяч на платформе
        # - if not ball.active: = "если мяч НЕ летит"
        # 
        # ЛОГИКА:
        # Мяч спит (False) → not False = True → кладем его на платформу
        # Мяч летит (True) → not True = False → не трогаем его
        # 
        # ЗАЧЕМ?
        # Если мяч спит, он должен оставаться на платформе и двигаться с ней
        # Если мяч летит, то не должен прилипать обратно к платформе
        if not ball.active:
            ball.rect.midbottom = platform.rect.midtop
        
        ball.update(platform)
        
        # ====================================================================
        # IF: if ball.rect.top > WINDOW_Y + WINDOW_HEIGHT:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - Проверяем вышел ли мяч за нижнюю границу экрана
        # - ball.rect.top это верхняя граница мяча
        # - WINDOW_Y + WINDOW_HEIGHT это нижняя граница поля (60 + 685 = 745)
        # - Если верхняя граница мяча БОЛЬШЕ чем нижняя граница поля
        # - Значит мяч полностью ушел вниз
        # 
        # ЛОГИКА:
        # ball.rect.top = 750 → 750 > 745 = True → мяч ушел, неудача
        # ball.rect.top = 700 → 700 > 745 = False → мяч еще видим
        # 
        # ЧТО ДЕЛАТЬ:
        # Вернуть мяч на платформу (деактивировать)
        if ball.rect.top > WINDOW_Y + WINDOW_HEIGHT:
            ball.active = False
        
        # Проверка столкновения с плитками
        for plitka in Plitka.vse_plitki:
            # ================================================================
            # IF: if destroy(plitka, ball):
            # ================================================================
            # ОБЪЯСНЕНИЕ:
            # - destroy() функция возвращает True если столкновение произошло
            # - Проверяем "произошло ли столкновение?"
            # 
            # ЛОГИКА:
            # Столкновение произошло → destroy() вернула True → +1 к счету
            # Столкновения не было → destroy() вернула False → ничего не делаем
            if destroy(plitka, ball):
                current_score += 1
        
        # Отрисовка
        screen.blit(background, (0, 0))
        
        for plitka in Plitka.vse_plitki:
            place_pl(screen, plitka)
        
        platform.draw(screen)
        ball.draw(screen)
        
        draw_score(screen, current_score, digit_images, 
                   display_x, display_y, digit_spacing, num_digits)
    
    # Обработка событий
    for event in pygame.event.get():
        # ====================================================================
        # IF: if event.type == pygame.QUIT:
        # ====================================================================
        # ОБЪЯСНЕНИЕ:
        # - event это событие (нажатие клавиши, закрытие окна и т.д.)
        # - event.type это тип события
        # - pygame.QUIT это событие "нажатие на крестик окна"
        # - Проверяем: пользователь закрыл окно?
        # 
        # ЛОГИКА:
        # Пользователь нажал крестик → event.type == pygame.QUIT = True
        # Пользователь нажал клавишу → event.type != pygame.QUIT = False
        # Пользователь двигнул мышь → event.type != pygame.QUIT = False
        if event.type == pygame.QUIT:
            finished = True
    
    pygame.display.update()
    clock.tick(FPS)


# ============================================================================
# ЗАВЕРШЕНИЕ
# ============================================================================

pygame.quit()
sys.exit()
